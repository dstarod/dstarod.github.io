<!doctype html><html lang=ru-RU><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Postgres: generate the most large followers intersections | Круг интересов</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Задача: получить список пользователей твиттера, с которыми у одного из них есть общие фоловеры, и отсортировать по их количеству. Лучше всего продемонстрировать на примере. Создадим таблицу с идентификаторами пользователей и фоловеров:
CREATE TEMP TABLE f(uid INT, fid INT);
INSERT INTO f(uid, fid) VALUES
    (1, 10), (1, 11), (1, 12), (1, 13), (1, 14),
    (2, 10), (2, 11), (2, 12),
    (3, 13), (3, 14),
    (4, 13), (4, 14), (4, 10), (4, 11)
;
А вот собственно и запрос, интересуют пересечения с пользователем 2, самые большие сверху."><meta name=generator content="Hugo 0.147.8"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=canonical href=https://dstarod.github.io/postgres-generate-most-large-followers/><meta property="og:url" content="https://dstarod.github.io/postgres-generate-most-large-followers/"><meta property="og:site_name" content="Круг интересов"><meta property="og:title" content="Postgres: generate the most large followers intersections"><meta property="og:description" content="Задача: получить список пользователей твиттера, с которыми у одного из них есть общие фоловеры, и отсортировать по их количеству. Лучше всего продемонстрировать на примере. Создадим таблицу с идентификаторами пользователей и фоловеров:
CREATE TEMP TABLE f(uid INT, fid INT); INSERT INTO f(uid, fid) VALUES (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (2, 10), (2, 11), (2, 12), (3, 13), (3, 14), (4, 13), (4, 14), (4, 10), (4, 11) ; А вот собственно и запрос, интересуют пересечения с пользователем 2, самые большие сверху."><meta property="og:locale" content="ru_RU"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-19T00:00:00+03:00"><meta property="article:modified_time" content="2016-01-19T00:00:00+03:00"><meta property="article:tag" content="Postgresql"><meta itemprop=name content="Postgres: generate the most large followers intersections"><meta itemprop=description content="Задача: получить список пользователей твиттера, с которыми у одного из них есть общие фоловеры, и отсортировать по их количеству. Лучше всего продемонстрировать на примере. Создадим таблицу с идентификаторами пользователей и фоловеров:
CREATE TEMP TABLE f(uid INT, fid INT); INSERT INTO f(uid, fid) VALUES (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (2, 10), (2, 11), (2, 12), (3, 13), (3, 14), (4, 13), (4, 14), (4, 10), (4, 11) ; А вот собственно и запрос, интересуют пересечения с пользователем 2, самые большие сверху."><meta itemprop=datePublished content="2016-01-19T00:00:00+03:00"><meta itemprop=dateModified content="2016-01-19T00:00:00+03:00"><meta itemprop=wordCount content="133"><meta itemprop=keywords content="Postgresql"><meta name=twitter:card content="summary"><meta name=twitter:title content="Postgres: generate the most large followers intersections"><meta name=twitter:description content="Задача: получить список пользователей твиттера, с которыми у одного из них есть общие фоловеры, и отсортировать по их количеству. Лучше всего продемонстрировать на примере. Создадим таблицу с идентификаторами пользователей и фоловеров:
CREATE TEMP TABLE f(uid INT, fid INT); INSERT INTO f(uid, fid) VALUES (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (2, 10), (2, 11), (2, 12), (3, 13), (3, 14), (4, 13), (4, 14), (4, 10), (4, 11) ; А вот собственно и запрос, интересуют пересечения с пользователем 2, самые большие сверху."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href class="f3 fw2 hover-white white-90 dib no-underline">Круг интересов</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Postgres: generate the most large followers intersections</h1><time class="f6 mv4 dib tracked" datetime=2016-01-19T00:00:00+03:00>января 19, 2016</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Задача: получить список пользователей твиттера, с которыми у одного из них есть общие фоловеры, и отсортировать по их количеству. Лучше всего продемонстрировать на примере. Создадим таблицу с идентификаторами пользователей и фоловеров:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> TEMP <span style=color:#66d9ef>TABLE</span> f(uid INT, fid INT);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> f(uid, fid) <span style=color:#66d9ef>VALUES</span>
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>10</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>11</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>12</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>13</span>), (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>14</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>10</span>), (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>11</span>), (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>12</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>13</span>), (<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>14</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>13</span>), (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>14</span>), (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>10</span>), (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>11</span>)
</span></span><span style=display:flex><span>;
</span></span></code></pre></div><p>А вот собственно и запрос, интересуют пересечения с пользователем 2, самые большие сверху.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> uid, array_agg(fid) followers_intersect
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> f <span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> uid
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> <span style=color:#66d9ef>cardinality</span>(
</span></span><span style=display:flex><span>    (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>SELECT</span> array_agg(a1) <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>unnest</span>(array_agg(fid)) a1
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>INNER</span> <span style=color:#66d9ef>JOIN</span> <span style=color:#66d9ef>unnest</span>(
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>SELECT</span> array_agg(fid) <span style=color:#66d9ef>FROM</span> f <span style=color:#66d9ef>WHERE</span> uid<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)::INT[]
</span></span><span style=display:flex><span>        ) a2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>ON</span> a1<span style=color:#f92672>=</span>a2
</span></span><span style=display:flex><span>    )::INT[]
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>DESC</span> NULLS <span style=color:#66d9ef>LAST</span>;
</span></span></code></pre></div><p>Результат, как и ожидалось:</p><pre tabindex=0><code>1. &#34;{10,11,12,13,14}&#34;
2. &#34;{10,11,12}&#34;
4. &#34;{13,14,10,11}&#34;
3. &#34;{13,14}&#34;
</code></pre><ul class=pa0><li class="list di"><a href=/tags/postgresql/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Postgresql</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href>&copy; Круг интересов 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>