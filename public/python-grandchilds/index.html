<!doctype html><html lang=ru-RU><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Python и пляски с процессами | Круг интересов</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Про использование нескольких процессов в Python уже написано невообразимое множество статей, хороших и не очень;
сломано немало копий в обсуждении проблемы GIL и псевдопотоков. Я же просто хочу рассказать о том, как решалась
задача с управлением небольшого дерева дочерних процессов.
Итак, исходная ситуация. Основной процесс запускает два дочерних, используя multiprocessing.Process, передает туда
очередь multiprocessing.Queue. Первый дочерний процесс просто собирает какие-то данные и пишет в очередь,
второй же запускает еще несколько процессов, куда передает ту-же очередь, с которой они и работают."><meta name=generator content="Hugo 0.147.8"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=canonical href=https://dstarod.github.io/python-grandchilds/><meta property="og:url" content="https://dstarod.github.io/python-grandchilds/"><meta property="og:site_name" content="Круг интересов"><meta property="og:title" content="Python и пляски с процессами"><meta property="og:description" content="Про использование нескольких процессов в Python уже написано невообразимое множество статей, хороших и не очень; сломано немало копий в обсуждении проблемы GIL и псевдопотоков. Я же просто хочу рассказать о том, как решалась задача с управлением небольшого дерева дочерних процессов.
Итак, исходная ситуация. Основной процесс запускает два дочерних, используя multiprocessing.Process, передает туда очередь multiprocessing.Queue. Первый дочерний процесс просто собирает какие-то данные и пишет в очередь, второй же запускает еще несколько процессов, куда передает ту-же очередь, с которой они и работают."><meta property="og:locale" content="ru_RU"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-01T00:00:00+03:00"><meta property="article:modified_time" content="2016-09-01T00:00:00+03:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Process"><meta itemprop=name content="Python и пляски с процессами"><meta itemprop=description content="Про использование нескольких процессов в Python уже написано невообразимое множество статей, хороших и не очень; сломано немало копий в обсуждении проблемы GIL и псевдопотоков. Я же просто хочу рассказать о том, как решалась задача с управлением небольшого дерева дочерних процессов.
Итак, исходная ситуация. Основной процесс запускает два дочерних, используя multiprocessing.Process, передает туда очередь multiprocessing.Queue. Первый дочерний процесс просто собирает какие-то данные и пишет в очередь, второй же запускает еще несколько процессов, куда передает ту-же очередь, с которой они и работают."><meta itemprop=datePublished content="2016-09-01T00:00:00+03:00"><meta itemprop=dateModified content="2016-09-01T00:00:00+03:00"><meta itemprop=wordCount content="548"><meta itemprop=keywords content="Python,Process"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python и пляски с процессами"><meta name=twitter:description content="Про использование нескольких процессов в Python уже написано невообразимое множество статей, хороших и не очень; сломано немало копий в обсуждении проблемы GIL и псевдопотоков. Я же просто хочу рассказать о том, как решалась задача с управлением небольшого дерева дочерних процессов.
Итак, исходная ситуация. Основной процесс запускает два дочерних, используя multiprocessing.Process, передает туда очередь multiprocessing.Queue. Первый дочерний процесс просто собирает какие-то данные и пишет в очередь, второй же запускает еще несколько процессов, куда передает ту-же очередь, с которой они и работают."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href class="f3 fw2 hover-white white-90 dib no-underline">Круг интересов</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Python и пляски с процессами</h1><time class="f6 mv4 dib tracked" datetime=2016-09-01T00:00:00+03:00>сентября 1, 2016</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Про использование нескольких процессов в Python уже написано невообразимое множество статей, хороших и не очень;
сломано немало копий в обсуждении проблемы GIL и псевдопотоков. Я же просто хочу рассказать о том, как решалась
задача с управлением небольшого дерева дочерних процессов.</p><p>Итак, исходная ситуация. Основной процесс запускает два дочерних, используя <code>multiprocessing.Process</code>, передает туда
очередь <code>multiprocessing.Queue</code>. Первый дочерний процесс просто собирает какие-то данные и пишет в очередь,
второй же запускает еще несколько процессов, куда передает ту-же очередь, с которой они и работают.</p><h2 id=задача-1-завершение-родительского-процесса-по-любой-причине-должно-вызывать-автоматическое-завершение-всех-дочерних>Задача 1: Завершение родительского процесса по любой причине должно вызывать автоматическое завершение всех дочерних.</h2><p>Как известно, чтобы дочерний процесс не остался висеть после завершения родительского и не стал зомби, нужно вызвать его метод <code>join</code>.
Это блокирующий метод, который остановит основной поток выполнения до завершения дочернего процесса. Другой вариант -
выставление свойства <code>daemon</code> дочернего процесса в <code>True</code>, что приведет к автоматическому его завершению после закрытия родителя.</p><p>В простых случаях этого достаточно. Правда, второй метод нельзя использовать для процессов, которые должны в свою очередь запускать другие процессы.
В этой ситуации явно вызывать <code>join</code> процесса при корректном завершении основного потока можно с помощью <code>atexit</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Process
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> atexit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        print(i)
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Blocking</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> Process(target<span style=color:#f92672>=</span>func)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>join()  <span style=color:#75715e># Waiting for 10 seconds</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Daemonized</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> Process(target<span style=color:#f92672>=</span>func)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@atexit.register</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>clean</span>():
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>terminate()
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>join()
</span></span></code></pre></div><p>Но все это не очень помогает, если родительский процесс убивают извне, например используя команду <code>kill</code>.
Хорошо, что у нас есть модуль <code>signal</code>, позволяющий повесить реакцию на системные сообщения. Например, вместо <code>atexit</code> повесим реакцию
на обычный <code>kill</code> (по умолчанию он посылает код SIGTERM):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>clean</span>(signum, frame):
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>terminate()
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTERM, clean)
</span></span></code></pre></div><p>Можно также упростить себе жизнь, если дочерних процессов много. Для этого сначала определим себе группу процессов, а потом отправим
сообщение сразу всей группе:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>setpgrp()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>clean</span>(signum, frame):
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>killpg(<span style=color:#ae81ff>0</span>, signal<span style=color:#f92672>.</span>SIGKILL)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTERM, clean)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... Start our child-processes ...</span>
</span></span></code></pre></div><h2 id=задача-2-завершение-родительского-процесса-при-падении-дочернего-по-любой-причине>Задача 2. Завершение родительского процесса при падении дочернего по любой причине</h2><p>Тут тоже гроздь способов, один другого лучше. Первый заключается в создании треда в основном процессе, который будет периодически
проверять объекты процессов, вызывая у них метод <code>is_alive</code>, и в случае значения False хотя бы у одного вызывать тот же os.killpg(0, signal.SIGTERM).
Второй - это тот-же <code>atexit</code> для обработки корректного завершения изнутри дочернего процесса. Ну и наконец ловля событий с использованием модуля <code>signal</code>.</p><h2 id=задача-3-завершение-дочернего-процесса-при-смене-родителя-перемещение-на-init>Задача 3. Завершение дочернего процесса при смене родителя (перемещение на init)</h2><p>Ну и наконец ситуация, когда родительский процесс убит быстро и в голову, например отправкой SIGKILL (<code>kill -9 pid</code>). В этом случае обработать закрытие процесса
не поможет ни <code>signal</code>, ни <code>atexit</code>. Дочерние процессы вываливаются и их родителем становится корневой процесс OS, для linux это будет видимо <code>init</code>.
А это значит, что обработкой придется заниматься дочернему процессу, который внезапно получил другого родителя. Ну в общем, почему бы и нет? Всего то и нужно -
получить PID родительского процесса и периодически проверять, не изменился ли он.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>parent_pid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getppid()
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>getppid() <span style=color:#f92672>!=</span> parent_pid:
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>9</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><h2 id=задача-4-закрытие-процесса-если-он-слишком-долго-живет>Задача 4. Закрытие процесса, если он слишком долго живет</h2><p>Также бывает такое, что процесс должен обязательно завершиться за ограниченное время, причины могут быть разные, не суть. Решения тоже возможны всякие, но вот
например с использованием модуля <code>signal</code>: вешаем слушателя собщения на SIGALARM и отправляем себе таковое через 10 секунд:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>alarm_quit</span>():
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>9</span>)
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGALRM, alarm_quit)
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>alarm(<span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><ul class=pa0><li class="list di"><a href=/tags/python/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Python</a></li><li class="list di"><a href=/tags/process/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Process</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Схожие</p><ul class="pa0 list"><li class=mb2><a href=/python-nltk-stanford-nlp/>Python NLTK + Stanford NLP</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href>&copy; Круг интересов 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>